<!DOCTYPE html><html lang="es"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'undefined', {
                page_path: window.location.pathname,
              });
            </script><meta property="og:image" content="clean.jpg"/><title>La arquitectura limpia no existe | Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo.</title><meta name="description" content="Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo."/><meta property="og:site_name" content="La arquitectura limpia no existe"/><meta property="og:description" content="Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo."/><meta name="twitter:title" content="La arquitectura limpia no existe"/><meta name="twitter:description" content="Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo."/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@sediceyerom"/><meta name="next-head-count" content="12"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-64555470-7"></script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
              
                gtag('config', 'UA-64555470-7');
              </script><meta name="robots" content="follow, index"/><link rel="preload" href="/_next/static/css/be449db308c0ad34.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/be449db308c0ad34.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/d452c9af5018a1a5.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d452c9af5018a1a5.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-52e9cfbc4046e97f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-10c760563a38045b.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/519-6e849adec6c21d1c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-6fb5b93ae0083e69.js" defer="" crossorigin=""></script><script src="/_next/static/Q3ZvsOPy3uJV4mCqHQvRJ/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/Q3ZvsOPy3uJV4mCqHQvRJ/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="antialiased leading-7 bg-white transition-colors duration-500 dark:bg-black dark:text-white"><div id="__next"><main class="px-6 sm:px-8 pt-16 pb-32 max-w-screen-md mx-auto"><header class="pb-12 flex justify-between items-baseline"><div class="space-y-2"><h1 class="font-bold text-3xl sm:text-4xl">Jerome Olvera</h1><h2 class="text-lg sm:text-xl opacity-90 dark:opacity-100">Software Engineer</h2></div><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium text-indigo-800 dark:text-yellow-300 bg-indigo-800 dark:bg-yellow-300 border-indigo-800 dark:border-yellow-300 dark:bg-opacity-10 px-2 py-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg></button></header><nav class="flex flex-wrap space-x-3 pb-16"><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="https://github.com/jerolan">Github</a></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="https://twitter.com/sediceyerom">Twitter</a></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="/blog">Blog</a></button></nav><div style="transition-property:top" class="fixed duration-300 left-0 right-0 z-50 bg-white dark:bg-black bg-opacity-80 dark:bg-opacity-80 backdrop-filter backdrop-blur"><div class="px-6 sm:px-8 py-6 sm:py-8 max-w-screen-md mx-auto flex justify-between items-center"><button><span class="font-bold text-md md:text-xl">La arquitectura limpia no existe</span></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium text-indigo-800 dark:text-yellow-300 bg-indigo-800 dark:bg-yellow-300 border-indigo-800 dark:border-yellow-300 dark:bg-opacity-10 px-2 py-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg></button></div></div><h1 class="font-bold text-3xl md:text-4xl pb-12">La arquitectura limpia no existe</h1><div class="pb-8 space-y-3"><div class="relative h-96 w-full"><img alt="Sere honesto contigo dev. No existe la Clean Architecture" loading="lazy" decoding="async" data-nimg="fill" class="object-contain object-center" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="/images/clean.jpg"/></div><p class="text-center text-sm italic opacity-80">Sere honesto contigo dev. No existe la Clean Architecture</p></div><div class="Markdown_markdown__gL5wC"><p>Clean Architecture, un tema que se ha vuelto tan esencial en las conversaciones sobre las mejores prácticas en desarrollo de software que es casi imposible asistir a una entrevista técnica o leer un hilo de discusión sobre el tema sin encontrarlo. Es un término que nos promete un santo grial de la programación: separación, mantenibilidad, y un software que no solo funciona bien sino que también es una alegría para trabajar.</p>
<p>Cuando me sumergí por primera vez en el mundo de Clean Architecture, seguí un camino que muchos ingenieros recorren. Busqué en YouTube, blogs, etc. Y, como muchos, mi primer punto de referencia fue su artículo original en el Clean Code Blog.</p>
<p>Cuando las conversaciones sobre clean arquitecture comienzan con el siguiente diagrama, sabemos que no vamos a ir en una buena dirección:</p>
<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="Clean arquitecture?"></p>
<p>Este articulo se enfoca principalmente en comprender a que se refieren los elementos presentados en el articulo de Uncle Bob y contrastarlos contra lo que el libro: Clean Architecture nos dice.</p>
<p>Siguiendo alguno de los ejemplos que alguno de estos blogs en internet nos puedas dar, nos encontramos con que la arquitectura limpia se ve algo así:</p>
<pre><code>- src
- - application
- - domain
- - infrastructure
- - interfaces
</code></pre>
<p>El problema de esto es que es meramente un ejemplo, no quiere decir que tu aplicación o todas las aplicaciones deban verse de esta forma. De hecho el mismo blog de Uncle Bob nos dice:</p>
<blockquote>
<p>Only Four Circles? No, the circles are schematic. You may find that you need more than just these four. There’s no rule that says you must always have just these four. However, The Dependency Rule always applies.</p>
</blockquote>
<h2>De que trata Clean Architecture, el libro?</h2>
<p>Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo.</p>
<p>El libro comienza estableciendo un marco para entender la "Arquitectura y Diseño" y alerta sobre los riesgos de no invertir en un buen diseño. Aquí, el autor argumenta convincentemente que los costos de mantenimiento y desarrollo pueden dispararse con el tiempo si la arquitectura no es sólida desde el comienzo.</p>
<p>Respecto a los paradigmas de programación, Martin nos lleva a través de un recorrido que subraya cómo el software es usualmente la combinación de varios de estos paradigmas y no dogmáticamente uno sobre otro.</p>
<p>Sobre todo, el libro es un tratado sobre principios — desde los principios SOLID hasta los principios de Componentes, Arquitectura y Capas —, culminando en la discusión de patrones de diseño comunes que sirven para cumplir con lo que podría considerarse el corazón de Clean Architecture: <em>The Dependency Rule</em>.</p>
<h2>The Dependency Rule y la verdadera esencia de Clean Architecture</h2>
<p>Si pudiera ejemplificar brevemente la esencia de Clean Architecture en un ejemplo de código, seria algo asi:</p>
<pre><code>import React, { useReducer, useCallback, FormEvent } from "react";

// Esta interfaz representa el contrato para la capa de lógica de negocio.
// Define la regla de negocio específica de la aplicación para crear un usuario.
interface ICreateUserService {
  (data: { name: string; email: string }): Promise&#x3C;void>;
}

// Este hook representa la implementación del caso de uso.
// Idealmente debería estar en un archivo separado y podría mejorarse
// inyectando dependencias que realicen las solicitudes de red reales,
// haciéndolo más adaptable a cambios en servicios externos.
function useCreateUserService(): ICreateUserService {
  const execute = useCallback(async ({ name, email }) => {
    // Aquí es donde normalmente interactuarías con un servicio externo,
    // como una API. La interacción con la API debería ser extraída a un
    // módulo separado para adherirse al Principio de Inversión de Dependencias.
    await new Promise((resolve) => setTimeout(resolve, 2000));
    console.debug(`User created: ${name} (${email})`);
  }, []);

  return execute;
}

// This represents the initial state of the form and should be self-explanatory.
const initialState = {
  name: "",
  email: "",
  loading: false,
};

type State = typeof initialState;

type Action = {
  type: "SET_NAME" | "SET_EMAIL" | "SET_LOADING" | "RESET_FORM";
  payload?: Partial&#x3C;State>;
};

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "SET_NAME":
      return { ...state, name: action.payload!.name! };
    case "SET_EMAIL":
      return { ...state, email: action.payload!.email! };
    case "SET_LOADING":
      return { ...state, loading: action.payload!.loading! };
    case "RESET_FORM":
      return initialState;
    default:
      return state;
  }
}

// Este componente representa parte de la capa UI.
// Debería ser responsable solo de renderizar y delegar interacciones de usuario
// a los casos de uso/reglas de negocio.
function UserForm({ createUser }: { createUser: ICreateUserService }) {
  const [state, dispatch] = useReducer(reducer, initialState);

  // Este callback representa la interacción del usuario con el formulario.
  // Podria ser extraido a un componente separado para adherirse al Principio de Responsabilidad Única.
  const handleSubmit = useCallback(
    async (e: FormEvent) => {
      e.preventDefault();
      dispatch({ type: "SET_LOADING", payload: { loading: true } });
      try {
        await createUser({ name: state.name, email: state.email });
        dispatch({ type: "RESET_FORM" });
      } finally {
        dispatch({ type: "SET_LOADING", payload: { loading: false } });
      }
    },
    [createUser, state],
  );

  // Los elementos del formulario deberían extraerse en componentes separados
  // para adherirse al Principio de Responsabilidad Única.
  return (
    &#x3C;form onSubmit={handleSubmit}>
      &#x3C;input
        placeholder="name"
        type="text"
        value={state.name}
        onChange={(e) =>
          dispatch({ type: "SET_NAME", payload: { name: e.target.value } })
        }
      />
      &#x3C;br />
      &#x3C;input
        placeholder="email"
        type="email"
        value={state.email}
        onChange={(e) =>
          dispatch({ type: "SET_EMAIL", payload: { name: e.target.value } })
        }
      />
      &#x3C;br />
      &#x3C;button disabled={state.loading} type="submit">
        Create User
      &#x3C;/button>
    &#x3C;/form>
  );
}

// Este componente App es parte de la capa más externa que compone la UI con los casos de uso.
export default function App() {
  const createUser = useCreateUserService();
  return &#x3C;UserForm createUser={createUser} />;
}

</code></pre>
<p>El código satisface a la Clean Architecture dado que:</p>
<p>Separación de preocupaciones: El código intenta separar las responsabilidades dividiendo la lógica en funciones y componentes. La interfaz ICreateUserService define un contrato para la creación de usuarios, y el hook useCreateUserService implementa esta lógica. Esto es coherente con los principios de Clean Architecture de separar las reglas de negocio de la UI.</p>
<p>La Regla de Dependencia: La Regla de Dependencia establece que las dependencias deben apuntar hacia adentro, desde las capas externas (como la UI) hacia las capas internas (como la lógica de negocio y los datos). En el código proporcionado, el componente UserForm depende de ICreateUserService, lo que es un buen ejemplo de inversión de dependencias y la separación entre la UI y la lógica de negocio.</p>
<p>Principios SOLID: El principio de Inversión de Dependencias (D en SOLID) está presente en la interfaz ICreateUserService.</p>
<h2>En conclusión</h2>
<p>Como lo dice el buen libro de <a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea">Eric Eliot, Composing Software</a>. La composicion es la esencia de la programación. El ejemplo que vimos se reduce a aplicar en React simple composicion, de forma que, todos los principios y reglas que conforman la arquitectura tienen un mismo origen que la programacion misma y la Rule of Dependency es solo un alias de la composicion.</p>
<p>El proceso de diseño y arquitectura no se basa en seguir un ejemplo o una guia MVC, MVP, MVVM, etc. Se basa en entender los principios y reglas que de tan herramientas y patrones de diseño, y aplicarlos de forma que se adapten a tu problema. No existe una estructura definida llamada "Clean Arquitecture" por Uncle Bob. Uncle Bob solo nos dio una guia de los principios y reglas que el usa para diseñar software, y que tu puedes usar para diseñar el tuyo.</p>
<p>Alguna otra referencia que me gusta muchos sobre separaciones por capas <a href="https://www.gobeyond.dev/packages-as-layers/">Packages as layers, not groups</a>.</p>
</div></main></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"title":"La arquitectura limpia no existe","date":"2023-11-09T00:00:00.000Z","slug":"clean-arquitecture","content":"\u003cp\u003eClean Architecture, un tema que se ha vuelto tan esencial en las conversaciones sobre las mejores prácticas en desarrollo de software que es casi imposible asistir a una entrevista técnica o leer un hilo de discusión sobre el tema sin encontrarlo. Es un término que nos promete un santo grial de la programación: separación, mantenibilidad, y un software que no solo funciona bien sino que también es una alegría para trabajar.\u003c/p\u003e\n\u003cp\u003eCuando me sumergí por primera vez en el mundo de Clean Architecture, seguí un camino que muchos ingenieros recorren. Busqué en YouTube, blogs, etc. Y, como muchos, mi primer punto de referencia fue su artículo original en el Clean Code Blog.\u003c/p\u003e\n\u003cp\u003eCuando las conversaciones sobre clean arquitecture comienzan con el siguiente diagrama, sabemos que no vamos a ir en una buena dirección:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg\" alt=\"Clean arquitecture?\"\u003e\u003c/p\u003e\n\u003cp\u003eEste articulo se enfoca principalmente en comprender a que se refieren los elementos presentados en el articulo de Uncle Bob y contrastarlos contra lo que el libro: Clean Architecture nos dice.\u003c/p\u003e\n\u003cp\u003eSiguiendo alguno de los ejemplos que alguno de estos blogs en internet nos puedas dar, nos encontramos con que la arquitectura limpia se ve algo así:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e- src\n- - application\n- - domain\n- - infrastructure\n- - interfaces\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl problema de esto es que es meramente un ejemplo, no quiere decir que tu aplicación o todas las aplicaciones deban verse de esta forma. De hecho el mismo blog de Uncle Bob nos dice:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOnly Four Circles? No, the circles are schematic. You may find that you need more than just these four. There’s no rule that says you must always have just these four. However, The Dependency Rule always applies.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eDe que trata Clean Architecture, el libro?\u003c/h2\u003e\n\u003cp\u003eContrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo.\u003c/p\u003e\n\u003cp\u003eEl libro comienza estableciendo un marco para entender la \"Arquitectura y Diseño\" y alerta sobre los riesgos de no invertir en un buen diseño. Aquí, el autor argumenta convincentemente que los costos de mantenimiento y desarrollo pueden dispararse con el tiempo si la arquitectura no es sólida desde el comienzo.\u003c/p\u003e\n\u003cp\u003eRespecto a los paradigmas de programación, Martin nos lleva a través de un recorrido que subraya cómo el software es usualmente la combinación de varios de estos paradigmas y no dogmáticamente uno sobre otro.\u003c/p\u003e\n\u003cp\u003eSobre todo, el libro es un tratado sobre principios — desde los principios SOLID hasta los principios de Componentes, Arquitectura y Capas —, culminando en la discusión de patrones de diseño comunes que sirven para cumplir con lo que podría considerarse el corazón de Clean Architecture: \u003cem\u003eThe Dependency Rule\u003c/em\u003e.\u003c/p\u003e\n\u003ch2\u003eThe Dependency Rule y la verdadera esencia de Clean Architecture\u003c/h2\u003e\n\u003cp\u003eSi pudiera ejemplificar brevemente la esencia de Clean Architecture en un ejemplo de código, seria algo asi:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport React, { useReducer, useCallback, FormEvent } from \"react\";\n\n// Esta interfaz representa el contrato para la capa de lógica de negocio.\n// Define la regla de negocio específica de la aplicación para crear un usuario.\ninterface ICreateUserService {\n  (data: { name: string; email: string }): Promise\u0026#x3C;void\u003e;\n}\n\n// Este hook representa la implementación del caso de uso.\n// Idealmente debería estar en un archivo separado y podría mejorarse\n// inyectando dependencias que realicen las solicitudes de red reales,\n// haciéndolo más adaptable a cambios en servicios externos.\nfunction useCreateUserService(): ICreateUserService {\n  const execute = useCallback(async ({ name, email }) =\u003e {\n    // Aquí es donde normalmente interactuarías con un servicio externo,\n    // como una API. La interacción con la API debería ser extraída a un\n    // módulo separado para adherirse al Principio de Inversión de Dependencias.\n    await new Promise((resolve) =\u003e setTimeout(resolve, 2000));\n    console.debug(`User created: ${name} (${email})`);\n  }, []);\n\n  return execute;\n}\n\n// This represents the initial state of the form and should be self-explanatory.\nconst initialState = {\n  name: \"\",\n  email: \"\",\n  loading: false,\n};\n\ntype State = typeof initialState;\n\ntype Action = {\n  type: \"SET_NAME\" | \"SET_EMAIL\" | \"SET_LOADING\" | \"RESET_FORM\";\n  payload?: Partial\u0026#x3C;State\u003e;\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"SET_NAME\":\n      return { ...state, name: action.payload!.name! };\n    case \"SET_EMAIL\":\n      return { ...state, email: action.payload!.email! };\n    case \"SET_LOADING\":\n      return { ...state, loading: action.payload!.loading! };\n    case \"RESET_FORM\":\n      return initialState;\n    default:\n      return state;\n  }\n}\n\n// Este componente representa parte de la capa UI.\n// Debería ser responsable solo de renderizar y delegar interacciones de usuario\n// a los casos de uso/reglas de negocio.\nfunction UserForm({ createUser }: { createUser: ICreateUserService }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Este callback representa la interacción del usuario con el formulario.\n  // Podria ser extraido a un componente separado para adherirse al Principio de Responsabilidad Única.\n  const handleSubmit = useCallback(\n    async (e: FormEvent) =\u003e {\n      e.preventDefault();\n      dispatch({ type: \"SET_LOADING\", payload: { loading: true } });\n      try {\n        await createUser({ name: state.name, email: state.email });\n        dispatch({ type: \"RESET_FORM\" });\n      } finally {\n        dispatch({ type: \"SET_LOADING\", payload: { loading: false } });\n      }\n    },\n    [createUser, state],\n  );\n\n  // Los elementos del formulario deberían extraerse en componentes separados\n  // para adherirse al Principio de Responsabilidad Única.\n  return (\n    \u0026#x3C;form onSubmit={handleSubmit}\u003e\n      \u0026#x3C;input\n        placeholder=\"name\"\n        type=\"text\"\n        value={state.name}\n        onChange={(e) =\u003e\n          dispatch({ type: \"SET_NAME\", payload: { name: e.target.value } })\n        }\n      /\u003e\n      \u0026#x3C;br /\u003e\n      \u0026#x3C;input\n        placeholder=\"email\"\n        type=\"email\"\n        value={state.email}\n        onChange={(e) =\u003e\n          dispatch({ type: \"SET_EMAIL\", payload: { name: e.target.value } })\n        }\n      /\u003e\n      \u0026#x3C;br /\u003e\n      \u0026#x3C;button disabled={state.loading} type=\"submit\"\u003e\n        Create User\n      \u0026#x3C;/button\u003e\n    \u0026#x3C;/form\u003e\n  );\n}\n\n// Este componente App es parte de la capa más externa que compone la UI con los casos de uso.\nexport default function App() {\n  const createUser = useCreateUserService();\n  return \u0026#x3C;UserForm createUser={createUser} /\u003e;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl código satisface a la Clean Architecture dado que:\u003c/p\u003e\n\u003cp\u003eSeparación de preocupaciones: El código intenta separar las responsabilidades dividiendo la lógica en funciones y componentes. La interfaz ICreateUserService define un contrato para la creación de usuarios, y el hook useCreateUserService implementa esta lógica. Esto es coherente con los principios de Clean Architecture de separar las reglas de negocio de la UI.\u003c/p\u003e\n\u003cp\u003eLa Regla de Dependencia: La Regla de Dependencia establece que las dependencias deben apuntar hacia adentro, desde las capas externas (como la UI) hacia las capas internas (como la lógica de negocio y los datos). En el código proporcionado, el componente UserForm depende de ICreateUserService, lo que es un buen ejemplo de inversión de dependencias y la separación entre la UI y la lógica de negocio.\u003c/p\u003e\n\u003cp\u003ePrincipios SOLID: El principio de Inversión de Dependencias (D en SOLID) está presente en la interfaz ICreateUserService.\u003c/p\u003e\n\u003ch2\u003eEn conclusión\u003c/h2\u003e\n\u003cp\u003eComo lo dice el buen libro de \u003ca href=\"https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea\"\u003eEric Eliot, Composing Software\u003c/a\u003e. La composicion es la esencia de la programación. El ejemplo que vimos se reduce a aplicar en React simple composicion, de forma que, todos los principios y reglas que conforman la arquitectura tienen un mismo origen que la programacion misma y la Rule of Dependency es solo un alias de la composicion.\u003c/p\u003e\n\u003cp\u003eEl proceso de diseño y arquitectura no se basa en seguir un ejemplo o una guia MVC, MVP, MVVM, etc. Se basa en entender los principios y reglas que de tan herramientas y patrones de diseño, y aplicarlos de forma que se adapten a tu problema. No existe una estructura definida llamada \"Clean Arquitecture\" por Uncle Bob. Uncle Bob solo nos dio una guia de los principios y reglas que el usa para diseñar software, y que tu puedes usar para diseñar el tuyo.\u003c/p\u003e\n\u003cp\u003eAlguna otra referencia que me gusta muchos sobre separaciones por capas \u003ca href=\"https://www.gobeyond.dev/packages-as-layers/\"\u003ePackages as layers, not groups\u003c/a\u003e.\u003c/p\u003e\n","cover":{"alt":"Sere honesto contigo dev. No existe la Clean Architecture","src":"clean.jpg"},"excerpt":"Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo."}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"clean-arquitecture"},"buildId":"Q3ZvsOPy3uJV4mCqHQvRJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>