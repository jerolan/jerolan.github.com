<!DOCTYPE html><html lang="es"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-64555470-7"></script><meta property="og:image" content="como-utilizo-copilot-para-escribir-codigo/cover.png" data-next-head=""/><title data-next-head="">¿Cómo utilizo Copilot para escribir código? | Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código.</title><meta name="description" content="Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código." data-next-head=""/><meta property="og:site_name" content="¿Cómo utilizo Copilot para escribir código?" data-next-head=""/><meta property="og:description" content="Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código." data-next-head=""/><meta name="twitter:title" content="¿Cómo utilizo Copilot para escribir código?" data-next-head=""/><meta name="twitter:description" content="Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código." data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:site" content="@sediceyerom" data-next-head=""/><meta name="robots" content="follow, index"/><link rel="preload" href="/_next/static/chunks/94ac632fbb06806a.css" as="style"/><link rel="preload" href="/_next/static/chunks/0ccb37f67aee2d1b.css" as="style"/><script data-next-head="">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', '398760427', {
                page_path: window.location.pathname,
              });
            </script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
              
                gtag('config', 'UA-64555470-7');
              </script><link rel="stylesheet" href="/_next/static/chunks/94ac632fbb06806a.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/chunks/0ccb37f67aee2d1b.css" data-n-p=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/3c10798eb79b6677.js" defer=""></script><script src="/_next/static/chunks/acf108a5e616596f.js" defer=""></script><script src="/_next/static/chunks/18001cb5f4d3fa4b.js" defer=""></script><script src="/_next/static/chunks/8c32ad85dabb85d4.js" defer=""></script><script src="/_next/static/chunks/turbopack-376024341b36e3b3.js" defer=""></script><script src="/_next/static/chunks/4eea677f485f38c0.js" defer=""></script><script src="/_next/static/chunks/86af771427cbed3a.js" defer=""></script><script src="/_next/static/chunks/turbopack-cca0bfbe9c0cab82.js" defer=""></script><script src="/_next/static/lmMzP2GYvozF4SS-w9Smt/_ssgManifest.js" defer=""></script><script src="/_next/static/lmMzP2GYvozF4SS-w9Smt/_buildManifest.js" defer=""></script></head><body class="antialiased leading-7 bg-white transition-colors duration-500 dark:bg-black dark:text-white"><div id="__next"><main class="px-6 sm:px-8 pt-16 pb-32 max-w-screen-md mx-auto"><header class="pb-12 flex justify-between items-baseline"><div class="space-y-2"><h1 class="font-bold text-3xl sm:text-4xl">Jerome Olvera</h1><h2 class="text-lg sm:text-xl opacity-90 dark:opacity-100">Software Engineer</h2></div><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium text-indigo-800 dark:text-yellow-300 bg-indigo-800 dark:bg-yellow-300 border-indigo-800 dark:border-yellow-300 dark:bg-opacity-10 px-2 py-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg></button></header><nav class="flex flex-wrap space-x-3 pb-16"><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="https://github.com/jerolan">Github</a></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="https://twitter.com/sediceyerom">Twitter</a></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium bg-red-400 dark:bg-red-300 text-red-400 dark:text-red-300 border-red-400 dark:border-red-300 px-4 py-1"><a href="/blog">Blog</a></button></nav><div style="transition-property:top" class="fixed duration-300 left-0 right-0 z-50 bg-white dark:bg-black bg-opacity-80 dark:bg-opacity-80 backdrop-filter backdrop-blur"><div class="px-6 sm:px-8 py-6 sm:py-8 max-w-screen-md mx-auto flex justify-between items-center"><button><span class="font-bold text-md md:text-xl">¿Cómo utilizo Copilot para escribir código?</span></button><button class="transition-opacity duration-300 hover:bg-transparent bg-opacity-5 dark:bg-opacity-5 border border-opacity-50 rounded p-2 font-medium text-indigo-800 dark:text-yellow-300 bg-indigo-800 dark:bg-yellow-300 border-indigo-800 dark:border-yellow-300 dark:bg-opacity-10 px-2 py-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg></button></div></div><h1 class="font-bold text-3xl md:text-4xl pb-12">¿Cómo utilizo Copilot para escribir código?</h1><div class="pb-8 space-y-3"><div class="relative h-96 w-full"><img alt="Github Copilot Cover" loading="lazy" decoding="async" data-nimg="fill" class="object-contain object-center" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="/images/como-utilizo-copilot-para-escribir-codigo/cover.png"/></div><p class="text-center text-sm italic opacity-80">Github Copilot Cover</p></div><div class="Markdown-module__GPd7sa__markdown"><h1><strong>¿Cómo utilizo Copilot para escribir código?</strong></h1>
<p>Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código. Con el tiempo, en función de las nuevas funcionalidades que cada IDE incorpora y de la capacidad de integrar modelos de IA directamente en el editor. Sin embargo, cada nueva característica introduce realmente una nueva manera de reducir el ciclo de copiar y pegar con el modelo y, en su lugar, permite que el modelo esté lo más cerca posible de aquello que queremos que logre.</p>
<p>Esta misma evolución la hemos visto dentro del propio ChatGPT, donde el flujo original consistía únicamente en una interfaz de chat. Si bien podías preguntarle al propio GPT sobre conocimiento general y el modelo respondía con cierto grado de precisión, cuando querías consultar elementos más específicos tenías que obtener datos de alguna fuente, pegarlos en la ventana de chat y, solo entonces, GPT podía ofrecer respuestas más acertadas.</p>
<p>Finalmente, el propio ChatGPT ha permitido hacer búsquedas en internet y cargar archivos y documentos. Incluso puede integrar apps (MCPs), lo que acerca aún más al modelo al contexto real de trabajo y anticipa el tipo de integración profunda que hoy ofrece Copilot dentro del IDE.</p>
<p>En este artículo nos vamos a enfocar en cómo utilizo GitHub Copilot, específicamente Copilot Chat integrado en un IDE como VS Code.</p>
<h2>Personalización</h2>
<p><a href="https://docs.github.com/en/copilot/concepts/prompting/response-customization">Copilot Chat permite personalizar</a> las respuestas del modelo a nivel de organización, personal y de proyecto. En mi caso, me he enfocado principalmente en la personalización por proyecto, utilizando el archivo principal de configuración <code>github/copilot-instructions.md</code> y archivos individuales <code>*.instructions.md</code>.</p>
<p>Si bien un buen inicio es describir los detalles del proyecto de forma clara y detallada en el archivo <code>copilot-instructions.md</code>, me he topado con dos limitaciones importantes: a veces el archivo se vuelve demasiado grande y complejo, por lo que, según el modelo que estés implementando, puedes obtener respuestas de baja calidad causadas por romper la ventana de contexto. La segunda limitación es que, personalmente, suelo trabajar en proyectos con múltiples tecnologías, por lo que patrones que para mí aplican bien en, por ejemplo, JavaScript, no necesariamente aplican de igual forma en SQL, C#, etc.</p>
<p>Para mitigar estas limitaciones, me he enfocado en crear archivos de instrucciones con diferentes propósitos según el contexto del proyecto que estoy modificando. Esto significa que un proyecto puede tener distintas capas: en el backend puedes tener API, Controllers, Application Services, Domain, etc.; en el frontend, UI Components, State Managers, Pages, etc. Además, puedes tener pequeños submódulos o librerías con propósitos particulares, como una librería de encriptación o una librería de acceso a datos.</p>
<p>Entonces, cuando estoy trabajando en agregar, modificar o corregir código en mi proyecto, no siempre modifico todas las capas y módulos al mismo tiempo; siempre me enfoco en una parte muy específica. Ya sea que esté agregando un nuevo endpoint o incorporando lógica de negocio nueva, en ese caso, prefiero segmentar mis archivos de instrucciones según el segmento de código que estoy modificando.</p>
<pre><code>my-project/
├─ backend/
│  ├─ api/
│  │  ├─ users/
│  │  │  └─ index.js
│  │  └─ auth/
│  │     └─ index.js
│  ├─ services/
│  │  └─ paymentService.js
│  └─ domain/
│     └─ order.js
├─ frontend/
│  ├─ components/
│  │  ├─ Button.js
│  │  └─ Header.js
│  └─ pages/
│     └─ checkout.js
├─ .github/
│  ├─ copilot-instructions.md
│  └─ instructions/
│     ├─ api-standard.instructions.md &#x3C;- Instrucciones para endpoints de API RESTful
│     ├─ domain-entities.instructions.md &#x3C;- Instrucciones para entidades de dominio
│     └─ ui-patterns.instructions.md &#x3C;- Instrucciones para componentes UI
</code></pre>
<p>La clave está en definir el propósito de cada archivo de instrucciones y asegurarse de que tenga la longitud adecuada para que el modelo pueda aprovecharlo, previniendo romper la ventana de contexto mas frecuentemente. Esto puede requerir algo de prueba y error, ya que cargar demasiados archivos de instrucciones puede tener el mismo efecto que simplemente tener un archivo muy grande.</p>
<h3>Estandarización de patrones</h3>
<p>Al inicio de la integration de Copilot Chat en mis equipos podia observar que bien, muchos developers resolvían actividades repetidas como escribir Tests y Documentation, si bien esto era un gran avance, aun podia ver como en los Code Reviews se seguían abordando temas relacionados con la estandarización de patrones y buenas prácticas.</p>
<p>En algún momento leí que <em>la calidad no es lo que predicas, es lo que toleras</em>. Esto me hizo reflexionar que, en los equipos y en las organizaciones, hay estándares y principios —que las personas hagan TDD, que sigan Clean Code, que documenten bien—, pero al final del día, si no hay una forma automatizada de hacer cumplir esos estándares, la calidad se diluye.</p>
<p>Para abordar este problema, la única forma de garantizar que los estándares se cumplan es automatizándolos. Existen muchas herramientas para hacer análisis estático de código, linters, formateadores, etc. Pero la parte más delicada llega cuando queremos garantizar que los patrones de diseño y las buenas prácticas se sigan en el código que se escribe día a día.</p>
<p>Aquí es donde los *.instructions.md juegan un papel fundamental para hacer cumplir estos estándares, pues si puedes automatizar tests y documentación con Copilot, ¿por qué no automatizar acuerdos para escribir eventos, principios de programación, hacks internos del proyecto, etc.?</p>
<p>Es muy probable que tú o tu equipo utilicen algún recurso documental interno de principios, segundad en la organization u obtengan información de algún libro o artículo que hayan decidido adoptar como estándar. Finalmente, a través de MCPs o redactando instrucciones claras en archivos *.instructions.md, puedes lograr que el modelo siga esos principios y patrones al momento de sugerir código.</p>
<p>Recientemente, un compañero me mostró <a href="https://context7.com/">context7</a>, al cual puedes acceder desde un MCP o simplemente copiar y pegar en algún archivo *.md. Context7 se encarga de resumir repositorios, artículos, etc., en un formato amigable para que los modelos de lenguaje puedan aprovechar ese contexto adicional.</p>
<p><img src="../images/como-utilizo-copilot-para-escribir-codigo/context7.png" alt="Context7"></p>
<h3>Documentation accidental</h3>
<p>Un estilo que he optado para redactar mis archivos para Copilot Chat es seguir un lenguaje natural, como si estuviera escribiendo documentación para que una persona la lea. Quizá esto sea algún antipatrón para escribir instrucciones para un LLM, pero me agrada que estos archivos no parezcan información digerida y mecánica.</p>
<p>En caso de relevar el proyecto a nuevos miembros del equipo, estos archivos pueden servir como documentación adicional para entender el propósito y las convenciones del proyecto, lo que facilita la incorporación de nuevos desarrolladores.</p>
<p>El beneficio de escribir archivos para Copilot Chat es inmediato: desde el primer prompt, inmediatamente después de refinar mis instrucciones, los resultados del modelo son de mayor calidad e, inmediatamente, otros compañeros del equipo se benefician de tener más y mejores módulos documentados.</p>
<h2>Construye tu agente base a ejemplos</h2>
<p>La mejor forma que he encontrado para crear mis archivos es explicarlos paso a paso como si se los estuviera enseñando a un nuevo miembro del equipo. De hecho, en la práctica esto se ha vuelto habitual: cuando un compañero tiene una duda sobre un patrón o módulo del proyecto, iniciamos una sesión de pair programming, abro mi editor y comenzamos una nueva ventana de Copilot Chat.</p>
<p><img src="../images/como-utilizo-copilot-para-escribir-codigo/Screenshot%202025-12-29%20at%200.29.34.png" alt="Chat1"></p>
<p>El flujo consiste en ir pidiéndole a Copilot que me explique qué hace el módulo o componente que estoy revisando; a medida que Copilot genera la explicación, le doy feedback y le pido que mejore o agregue más detalles, hasta que la explicación quede clara y completa. Una vez que estoy satisfecho con la explicación, le pido que genere el archivo .md.</p>
<p><img src="../images/como-utilizo-copilot-para-escribir-codigo/Screenshot%202025-12-29%20at%200.34.41.png" alt="Chat1"></p>
<p>El resultado no siempre es perfecto, pero es un excelente punto de partida que puedo ajustar y mejorar rápidamente. Es necesario ponerlo en práctica e ir afinando los parámetros para que el modelo haga exactamente lo que necesitamos.</p>
<blockquote>
<p>El siguiente prompt lo genere y refine tal para escribir este artículo: <a href="../.github/prompts/article-template-generator.prompt.md">article-template-generator.prompt.md</a>. Ademas de generar aquel punto de partida usando Copilot Chat suelo apoyarme de este otro Custom GPT en ChatGTP para que aplique las mejores practicas de como suelo modelar mis .md files <a href="https://chatgpt.com/g/g-68a7b356949c8191839aea1c9438e702-disenador-de-copilot-chat">Diseñador de Copilot Chat</a></p>
</blockquote>
<p>Extracto:</p>
<pre><code>---
name: Article Template Generator
description: Generate a Markdown article template with frontmatter and a slug-based filename.
argument-hint: title="Article title" description="Short article description"
agent: agent
model: GPT-4.1 (copilot)
tools: ['edit']
---

Your task is to generate a Markdown article template.

## Steps

1. Ask the user for the **article title** if it is not provided.
2. Ask the user for a **short description** if it is not provided.
3. Generate a **slug** from the title using these rules:
   - Convert to lowercase
   - Remove accents and diacritics
   - Replace spaces with hyphens
   - Remove all characters except letters, numbers, and hyphens
4. Use the slug as the **file name**, ending with `.md`.
5. Generate the following Markdown content:
</code></pre>
<h3>Escribir agentes no es tan distinto de programar</h3>
<p>Aun no es posible pedirle a ningún LLM que produzca el 100% del código respetando todos los estándares y patrones con un solo prompt.</p>
<blockquote>
<p>Haz un e-commerce.</p>
</blockquote>
<p>Como siempre el <em>diablo</em> está en los detalles, y ahi es donde eso de ser un Ingeniero de Software se vuelve relevante. Uno como profesional debe entender el problema y conocer las posibles soluciones, las mas adecuadas o las que mejor se adaptan al contexto del proyecto.</p>
<p>Finalmente eso se traduce en pequeños módulos, en pasos, condicionales, iteraciones, etc. Tantos detalles que parece que tus prompts se ven como pseudocódigo. Si miras otra vez el ejemplo del prompt anterior, hay una serie de pasos que el agente debe seguir para llegar al resultado esperado, son exactamente los mismos pasos que uno como desarrollador seguiría para resolver el problema.</p>
<p>Las instrucciones se alinean al tren de pensamiento que uno como desarrollador debe seguir para resolver un problema.</p>
<h2>Spec-Driven Development</h2>
<p>A la fecha hay dos recursos que me han motivado profundamente de seguir este camino de construir instrucciones y agentes para Copilot Chat.</p>
<p>El primer concepto fue <a href="https://kiro.dev/docs/specs/concepts/">Spec-Driven Development</a> planteado en la documentation y la fundación del editor Kiro, en lugar de escribir código directamente, comienza por la especificación ahi uno como profesional describe el comportamiento esperado del código. Estas especificaciones sirven como una guía para que los modelos de lenguaje generen código que cumpla con los requisitos definidos.</p>
<p>Esto no es muy distinto de las practicas comunes en desarrollo de software como BDD (Behavior-Driven Development) o TDD (Test-Driven Development), donde uno define el comportamiento esperado del sistema antes de escribir el código.</p>
<p>Solo que la interfaz en este caso cambia, directamente es un manual de instrucciones para que el modelo pueda seguir y generar código acorde a esas especificaciones. Yo siguiendo el estilo mencionado previamente sobre escribir instrucciones como si fuera documentation para humanos, tiendo a llegar a un resultado que si bien no es el 100% perfecto, acelera la generación de código boilerplate, y me permite enfocarme en los detalles más complejos del problema.</p>
<p>Estos mismos "planes" o "specs" me han ayudado durante sesiones de Pair Programming con compañeros, donde juntos definimos el comportamiento esperado de un módulo o componente, y luego puedo delegar a otro programador la tarea de implementar ese módulo siguiendo las especificaciones definidas.</p>
<p>Originalmente construía mis planes siguiendo los pasos descritos en el segmento anterior; sin embargo, Copilot Chat ahora cuenta con un <a href="https://code.visualstudio.com/docs/copilot/chat/chat-planning">"Plan Mode"</a> que permite iterar un tren de pensamiento antes de ejecutar cualquier cambio en el código, dándole al usuario la opción de aprobar o rechazar cada paso del plan.</p>
<p><img src="../images/como-utilizo-copilot-para-escribir-codigo/plan.png" alt="Plan Mode"></p>
<p>El segundo recurso fue la publicación de <a href="https://www.anthropic.com/news/disrupting-AI-espionage">Anthropic, Disrupting the first reported AI-orchestrated cyber espionage campaign</a>, este narra atacantes usaban Claude Code para orquestar e inyectar ataques automáticos basados en agentes</p>
<p>El articulo es interesante, sin embargo lo mas impactante para mi fue el diagrama de flujo utilizado para explicar el proceso de ataque, pues estos no son mas que pipelines de instrucciones para que un agente pueda seguir y ejecutar una serie de pasos.</p>
<p>Nuevamente son los mismos principios de descomponer en pequeños instrucciones, las cuales se ejecutan de forma secuencial partiendo desde un objetivo general, las cuales pueden tener forma de agentes o prompts.</p>
<p><img src="../images/como-utilizo-copilot-para-escribir-codigo/anthropic.png" alt="anthropic"></p>
<h3>Delegar tareas a un Agente</h3>
<p>Dentro de la pirámide de abstracción que uno puede lograr con los LLMs, una de las capas más interesantes es la de delegar tareas a un agente. Esta no es una capacidad que yo haya utilizado aun, pero, en teoría, si tienes un conjunto de instrucciones claras y bien definidas, luego tienes especificaciones de alto nivel sobre como esta constituido un modulo, puedes delegar la tarea de implementar ese módulo a un agente, tal como el artículo de Anthropic describe.</p>
<p>Supongo que eventualmente cuando haga uso de esa funcionalidad estaré actualizando este articulo con mis experiencias.</p>
<h2>En conclusión</h2>
<p>Los nuevos flujos de trabajo con IA desde la aparición de Copilot, GPT-3, etc., han evolucionado en una dirección que para mí se resume en: <em>cómo reducir el ciclo de copiar y pegar con el modelo y, en su lugar, permitir que el modelo esté lo más cerca posible de aquello que queremos que logre.</em></p>
<p>Escribir código con Copilot Chat es cada vez más parecido a simplemente escribir código de mejor calidad, ya que las buenas prácticas de toda la vida siguen siendo válidas: escribir código modular, reutilizable, documentado, testeado, etc. Al final, la IA solo logró que los ingenieros finalmente escribieran sus pruebas y documentación, segmentaran su tren de pensamiento en pasos claros y plasmaran todo eso en un recurso que cualquier persona pueda entender. Qué sorpresa, ¿no?</p>
</div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"¿Cómo utilizo Copilot para escribir código?","date":"2025-12-29","slug":"como-utilizo-copilot-para-escribir-codigo","content":"\u003ch1\u003e\u003cstrong\u003e¿Cómo utilizo Copilot para escribir código?\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eMi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código. Con el tiempo, en función de las nuevas funcionalidades que cada IDE incorpora y de la capacidad de integrar modelos de IA directamente en el editor. Sin embargo, cada nueva característica introduce realmente una nueva manera de reducir el ciclo de copiar y pegar con el modelo y, en su lugar, permite que el modelo esté lo más cerca posible de aquello que queremos que logre.\u003c/p\u003e\n\u003cp\u003eEsta misma evolución la hemos visto dentro del propio ChatGPT, donde el flujo original consistía únicamente en una interfaz de chat. Si bien podías preguntarle al propio GPT sobre conocimiento general y el modelo respondía con cierto grado de precisión, cuando querías consultar elementos más específicos tenías que obtener datos de alguna fuente, pegarlos en la ventana de chat y, solo entonces, GPT podía ofrecer respuestas más acertadas.\u003c/p\u003e\n\u003cp\u003eFinalmente, el propio ChatGPT ha permitido hacer búsquedas en internet y cargar archivos y documentos. Incluso puede integrar apps (MCPs), lo que acerca aún más al modelo al contexto real de trabajo y anticipa el tipo de integración profunda que hoy ofrece Copilot dentro del IDE.\u003c/p\u003e\n\u003cp\u003eEn este artículo nos vamos a enfocar en cómo utilizo GitHub Copilot, específicamente Copilot Chat integrado en un IDE como VS Code.\u003c/p\u003e\n\u003ch2\u003ePersonalización\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/en/copilot/concepts/prompting/response-customization\"\u003eCopilot Chat permite personalizar\u003c/a\u003e las respuestas del modelo a nivel de organización, personal y de proyecto. En mi caso, me he enfocado principalmente en la personalización por proyecto, utilizando el archivo principal de configuración \u003ccode\u003egithub/copilot-instructions.md\u003c/code\u003e y archivos individuales \u003ccode\u003e*.instructions.md\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSi bien un buen inicio es describir los detalles del proyecto de forma clara y detallada en el archivo \u003ccode\u003ecopilot-instructions.md\u003c/code\u003e, me he topado con dos limitaciones importantes: a veces el archivo se vuelve demasiado grande y complejo, por lo que, según el modelo que estés implementando, puedes obtener respuestas de baja calidad causadas por romper la ventana de contexto. La segunda limitación es que, personalmente, suelo trabajar en proyectos con múltiples tecnologías, por lo que patrones que para mí aplican bien en, por ejemplo, JavaScript, no necesariamente aplican de igual forma en SQL, C#, etc.\u003c/p\u003e\n\u003cp\u003ePara mitigar estas limitaciones, me he enfocado en crear archivos de instrucciones con diferentes propósitos según el contexto del proyecto que estoy modificando. Esto significa que un proyecto puede tener distintas capas: en el backend puedes tener API, Controllers, Application Services, Domain, etc.; en el frontend, UI Components, State Managers, Pages, etc. Además, puedes tener pequeños submódulos o librerías con propósitos particulares, como una librería de encriptación o una librería de acceso a datos.\u003c/p\u003e\n\u003cp\u003eEntonces, cuando estoy trabajando en agregar, modificar o corregir código en mi proyecto, no siempre modifico todas las capas y módulos al mismo tiempo; siempre me enfoco en una parte muy específica. Ya sea que esté agregando un nuevo endpoint o incorporando lógica de negocio nueva, en ese caso, prefiero segmentar mis archivos de instrucciones según el segmento de código que estoy modificando.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy-project/\n├─ backend/\n│  ├─ api/\n│  │  ├─ users/\n│  │  │  └─ index.js\n│  │  └─ auth/\n│  │     └─ index.js\n│  ├─ services/\n│  │  └─ paymentService.js\n│  └─ domain/\n│     └─ order.js\n├─ frontend/\n│  ├─ components/\n│  │  ├─ Button.js\n│  │  └─ Header.js\n│  └─ pages/\n│     └─ checkout.js\n├─ .github/\n│  ├─ copilot-instructions.md\n│  └─ instructions/\n│     ├─ api-standard.instructions.md \u0026#x3C;- Instrucciones para endpoints de API RESTful\n│     ├─ domain-entities.instructions.md \u0026#x3C;- Instrucciones para entidades de dominio\n│     └─ ui-patterns.instructions.md \u0026#x3C;- Instrucciones para componentes UI\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa clave está en definir el propósito de cada archivo de instrucciones y asegurarse de que tenga la longitud adecuada para que el modelo pueda aprovecharlo, previniendo romper la ventana de contexto mas frecuentemente. Esto puede requerir algo de prueba y error, ya que cargar demasiados archivos de instrucciones puede tener el mismo efecto que simplemente tener un archivo muy grande.\u003c/p\u003e\n\u003ch3\u003eEstandarización de patrones\u003c/h3\u003e\n\u003cp\u003eAl inicio de la integration de Copilot Chat en mis equipos podia observar que bien, muchos developers resolvían actividades repetidas como escribir Tests y Documentation, si bien esto era un gran avance, aun podia ver como en los Code Reviews se seguían abordando temas relacionados con la estandarización de patrones y buenas prácticas.\u003c/p\u003e\n\u003cp\u003eEn algún momento leí que \u003cem\u003ela calidad no es lo que predicas, es lo que toleras\u003c/em\u003e. Esto me hizo reflexionar que, en los equipos y en las organizaciones, hay estándares y principios —que las personas hagan TDD, que sigan Clean Code, que documenten bien—, pero al final del día, si no hay una forma automatizada de hacer cumplir esos estándares, la calidad se diluye.\u003c/p\u003e\n\u003cp\u003ePara abordar este problema, la única forma de garantizar que los estándares se cumplan es automatizándolos. Existen muchas herramientas para hacer análisis estático de código, linters, formateadores, etc. Pero la parte más delicada llega cuando queremos garantizar que los patrones de diseño y las buenas prácticas se sigan en el código que se escribe día a día.\u003c/p\u003e\n\u003cp\u003eAquí es donde los *.instructions.md juegan un papel fundamental para hacer cumplir estos estándares, pues si puedes automatizar tests y documentación con Copilot, ¿por qué no automatizar acuerdos para escribir eventos, principios de programación, hacks internos del proyecto, etc.?\u003c/p\u003e\n\u003cp\u003eEs muy probable que tú o tu equipo utilicen algún recurso documental interno de principios, segundad en la organization u obtengan información de algún libro o artículo que hayan decidido adoptar como estándar. Finalmente, a través de MCPs o redactando instrucciones claras en archivos *.instructions.md, puedes lograr que el modelo siga esos principios y patrones al momento de sugerir código.\u003c/p\u003e\n\u003cp\u003eRecientemente, un compañero me mostró \u003ca href=\"https://context7.com/\"\u003econtext7\u003c/a\u003e, al cual puedes acceder desde un MCP o simplemente copiar y pegar en algún archivo *.md. Context7 se encarga de resumir repositorios, artículos, etc., en un formato amigable para que los modelos de lenguaje puedan aprovechar ese contexto adicional.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../images/como-utilizo-copilot-para-escribir-codigo/context7.png\" alt=\"Context7\"\u003e\u003c/p\u003e\n\u003ch3\u003eDocumentation accidental\u003c/h3\u003e\n\u003cp\u003eUn estilo que he optado para redactar mis archivos para Copilot Chat es seguir un lenguaje natural, como si estuviera escribiendo documentación para que una persona la lea. Quizá esto sea algún antipatrón para escribir instrucciones para un LLM, pero me agrada que estos archivos no parezcan información digerida y mecánica.\u003c/p\u003e\n\u003cp\u003eEn caso de relevar el proyecto a nuevos miembros del equipo, estos archivos pueden servir como documentación adicional para entender el propósito y las convenciones del proyecto, lo que facilita la incorporación de nuevos desarrolladores.\u003c/p\u003e\n\u003cp\u003eEl beneficio de escribir archivos para Copilot Chat es inmediato: desde el primer prompt, inmediatamente después de refinar mis instrucciones, los resultados del modelo son de mayor calidad e, inmediatamente, otros compañeros del equipo se benefician de tener más y mejores módulos documentados.\u003c/p\u003e\n\u003ch2\u003eConstruye tu agente base a ejemplos\u003c/h2\u003e\n\u003cp\u003eLa mejor forma que he encontrado para crear mis archivos es explicarlos paso a paso como si se los estuviera enseñando a un nuevo miembro del equipo. De hecho, en la práctica esto se ha vuelto habitual: cuando un compañero tiene una duda sobre un patrón o módulo del proyecto, iniciamos una sesión de pair programming, abro mi editor y comenzamos una nueva ventana de Copilot Chat.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../images/como-utilizo-copilot-para-escribir-codigo/Screenshot%202025-12-29%20at%200.29.34.png\" alt=\"Chat1\"\u003e\u003c/p\u003e\n\u003cp\u003eEl flujo consiste en ir pidiéndole a Copilot que me explique qué hace el módulo o componente que estoy revisando; a medida que Copilot genera la explicación, le doy feedback y le pido que mejore o agregue más detalles, hasta que la explicación quede clara y completa. Una vez que estoy satisfecho con la explicación, le pido que genere el archivo .md.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../images/como-utilizo-copilot-para-escribir-codigo/Screenshot%202025-12-29%20at%200.34.41.png\" alt=\"Chat1\"\u003e\u003c/p\u003e\n\u003cp\u003eEl resultado no siempre es perfecto, pero es un excelente punto de partida que puedo ajustar y mejorar rápidamente. Es necesario ponerlo en práctica e ir afinando los parámetros para que el modelo haga exactamente lo que necesitamos.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEl siguiente prompt lo genere y refine tal para escribir este artículo: \u003ca href=\"../.github/prompts/article-template-generator.prompt.md\"\u003earticle-template-generator.prompt.md\u003c/a\u003e. Ademas de generar aquel punto de partida usando Copilot Chat suelo apoyarme de este otro Custom GPT en ChatGTP para que aplique las mejores practicas de como suelo modelar mis .md files \u003ca href=\"https://chatgpt.com/g/g-68a7b356949c8191839aea1c9438e702-disenador-de-copilot-chat\"\u003eDiseñador de Copilot Chat\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eExtracto:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---\nname: Article Template Generator\ndescription: Generate a Markdown article template with frontmatter and a slug-based filename.\nargument-hint: title=\"Article title\" description=\"Short article description\"\nagent: agent\nmodel: GPT-4.1 (copilot)\ntools: ['edit']\n---\n\nYour task is to generate a Markdown article template.\n\n## Steps\n\n1. Ask the user for the **article title** if it is not provided.\n2. Ask the user for a **short description** if it is not provided.\n3. Generate a **slug** from the title using these rules:\n   - Convert to lowercase\n   - Remove accents and diacritics\n   - Replace spaces with hyphens\n   - Remove all characters except letters, numbers, and hyphens\n4. Use the slug as the **file name**, ending with `.md`.\n5. Generate the following Markdown content:\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eEscribir agentes no es tan distinto de programar\u003c/h3\u003e\n\u003cp\u003eAun no es posible pedirle a ningún LLM que produzca el 100% del código respetando todos los estándares y patrones con un solo prompt.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHaz un e-commerce.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eComo siempre el \u003cem\u003ediablo\u003c/em\u003e está en los detalles, y ahi es donde eso de ser un Ingeniero de Software se vuelve relevante. Uno como profesional debe entender el problema y conocer las posibles soluciones, las mas adecuadas o las que mejor se adaptan al contexto del proyecto.\u003c/p\u003e\n\u003cp\u003eFinalmente eso se traduce en pequeños módulos, en pasos, condicionales, iteraciones, etc. Tantos detalles que parece que tus prompts se ven como pseudocódigo. Si miras otra vez el ejemplo del prompt anterior, hay una serie de pasos que el agente debe seguir para llegar al resultado esperado, son exactamente los mismos pasos que uno como desarrollador seguiría para resolver el problema.\u003c/p\u003e\n\u003cp\u003eLas instrucciones se alinean al tren de pensamiento que uno como desarrollador debe seguir para resolver un problema.\u003c/p\u003e\n\u003ch2\u003eSpec-Driven Development\u003c/h2\u003e\n\u003cp\u003eA la fecha hay dos recursos que me han motivado profundamente de seguir este camino de construir instrucciones y agentes para Copilot Chat.\u003c/p\u003e\n\u003cp\u003eEl primer concepto fue \u003ca href=\"https://kiro.dev/docs/specs/concepts/\"\u003eSpec-Driven Development\u003c/a\u003e planteado en la documentation y la fundación del editor Kiro, en lugar de escribir código directamente, comienza por la especificación ahi uno como profesional describe el comportamiento esperado del código. Estas especificaciones sirven como una guía para que los modelos de lenguaje generen código que cumpla con los requisitos definidos.\u003c/p\u003e\n\u003cp\u003eEsto no es muy distinto de las practicas comunes en desarrollo de software como BDD (Behavior-Driven Development) o TDD (Test-Driven Development), donde uno define el comportamiento esperado del sistema antes de escribir el código.\u003c/p\u003e\n\u003cp\u003eSolo que la interfaz en este caso cambia, directamente es un manual de instrucciones para que el modelo pueda seguir y generar código acorde a esas especificaciones. Yo siguiendo el estilo mencionado previamente sobre escribir instrucciones como si fuera documentation para humanos, tiendo a llegar a un resultado que si bien no es el 100% perfecto, acelera la generación de código boilerplate, y me permite enfocarme en los detalles más complejos del problema.\u003c/p\u003e\n\u003cp\u003eEstos mismos \"planes\" o \"specs\" me han ayudado durante sesiones de Pair Programming con compañeros, donde juntos definimos el comportamiento esperado de un módulo o componente, y luego puedo delegar a otro programador la tarea de implementar ese módulo siguiendo las especificaciones definidas.\u003c/p\u003e\n\u003cp\u003eOriginalmente construía mis planes siguiendo los pasos descritos en el segmento anterior; sin embargo, Copilot Chat ahora cuenta con un \u003ca href=\"https://code.visualstudio.com/docs/copilot/chat/chat-planning\"\u003e\"Plan Mode\"\u003c/a\u003e que permite iterar un tren de pensamiento antes de ejecutar cualquier cambio en el código, dándole al usuario la opción de aprobar o rechazar cada paso del plan.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../images/como-utilizo-copilot-para-escribir-codigo/plan.png\" alt=\"Plan Mode\"\u003e\u003c/p\u003e\n\u003cp\u003eEl segundo recurso fue la publicación de \u003ca href=\"https://www.anthropic.com/news/disrupting-AI-espionage\"\u003eAnthropic, Disrupting the first reported AI-orchestrated cyber espionage campaign\u003c/a\u003e, este narra atacantes usaban Claude Code para orquestar e inyectar ataques automáticos basados en agentes\u003c/p\u003e\n\u003cp\u003eEl articulo es interesante, sin embargo lo mas impactante para mi fue el diagrama de flujo utilizado para explicar el proceso de ataque, pues estos no son mas que pipelines de instrucciones para que un agente pueda seguir y ejecutar una serie de pasos.\u003c/p\u003e\n\u003cp\u003eNuevamente son los mismos principios de descomponer en pequeños instrucciones, las cuales se ejecutan de forma secuencial partiendo desde un objetivo general, las cuales pueden tener forma de agentes o prompts.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../images/como-utilizo-copilot-para-escribir-codigo/anthropic.png\" alt=\"anthropic\"\u003e\u003c/p\u003e\n\u003ch3\u003eDelegar tareas a un Agente\u003c/h3\u003e\n\u003cp\u003eDentro de la pirámide de abstracción que uno puede lograr con los LLMs, una de las capas más interesantes es la de delegar tareas a un agente. Esta no es una capacidad que yo haya utilizado aun, pero, en teoría, si tienes un conjunto de instrucciones claras y bien definidas, luego tienes especificaciones de alto nivel sobre como esta constituido un modulo, puedes delegar la tarea de implementar ese módulo a un agente, tal como el artículo de Anthropic describe.\u003c/p\u003e\n\u003cp\u003eSupongo que eventualmente cuando haga uso de esa funcionalidad estaré actualizando este articulo con mis experiencias.\u003c/p\u003e\n\u003ch2\u003eEn conclusión\u003c/h2\u003e\n\u003cp\u003eLos nuevos flujos de trabajo con IA desde la aparición de Copilot, GPT-3, etc., han evolucionado en una dirección que para mí se resume en: \u003cem\u003ecómo reducir el ciclo de copiar y pegar con el modelo y, en su lugar, permitir que el modelo esté lo más cerca posible de aquello que queremos que logre.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eEscribir código con Copilot Chat es cada vez más parecido a simplemente escribir código de mejor calidad, ya que las buenas prácticas de toda la vida siguen siendo válidas: escribir código modular, reutilizable, documentado, testeado, etc. Al final, la IA solo logró que los ingenieros finalmente escribieran sus pruebas y documentación, segmentaran su tren de pensamiento en pasos claros y plasmaran todo eso en un recurso que cualquier persona pueda entender. Qué sorpresa, ¿no?\u003c/p\u003e\n","cover":{"alt":"Github Copilot Cover","src":"como-utilizo-copilot-para-escribir-codigo/cover.png"},"excerpt":"Mi forma de integrar la IA en el flujo de trabajo ha evolucionado principalmente con un objetivo claro: reducir la fricción entre el modelo y el contexto real del código."}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"como-utilizo-copilot-para-escribir-codigo"},"buildId":"lmMzP2GYvozF4SS-w9Smt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>