{"pageProps":{"post":{"title":"La arquitectura limpia no existe","date":"2023-11-09T00:00:00.000Z","slug":"clean-arquitecture","content":"<p>Clean Architecture, un tema que se ha vuelto tan esencial en las conversaciones sobre las mejores prácticas en desarrollo de software que es casi imposible asistir a una entrevista técnica o leer un hilo de discusión sobre el tema sin encontrarlo. Es un término que nos promete un santo grial de la programación: separación, mantenibilidad, y un software que no solo funciona bien sino que también es una alegría para trabajar.</p>\n<p>Cuando me sumergí por primera vez en el mundo de Clean Architecture, seguí un camino que muchos ingenieros recorren. Busqué en YouTube, blogs, etc. Y, como muchos, mi primer punto de referencia fue su artículo original en el Clean Code Blog.</p>\n<p>Cuando las conversaciones sobre clean arquitecture comienzan con el siguiente diagrama, sabemos que no vamos a ir en una buena dirección:</p>\n<p><img src=\"https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg\" alt=\"Clean arquitecture?\"></p>\n<p>Este articulo se enfoca principalmente en comprender a que se refieren los elementos presentados en el articulo de Uncle Bob y contrastarlos contra lo que el libro: Clean Architecture nos dice.</p>\n<p>Siguiendo alguno de los ejemplos que alguno de estos blogs en internet nos puedas dar, nos encontramos con que la arquitectura limpia se ve algo así:</p>\n<pre><code>- src\n- - application\n- - domain\n- - infrastructure\n- - interfaces\n</code></pre>\n<p>El problema de esto es que es meramente un ejemplo, no quiere decir que tu aplicación o todas las aplicaciones deban verse de esta forma. De hecho el mismo blog de Uncle Bob nos dice:</p>\n<blockquote>\n<p>Only Four Circles? No, the circles are schematic. You may find that you need more than just these four. There’s no rule that says you must always have just these four. However, The Dependency Rule always applies.</p>\n</blockquote>\n<h2>De que trata Clean Architecture, el libro?</h2>\n<p>Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo.</p>\n<p>El libro comienza estableciendo un marco para entender la \"Arquitectura y Diseño\" y alerta sobre los riesgos de no invertir en un buen diseño. Aquí, el autor argumenta convincentemente que los costos de mantenimiento y desarrollo pueden dispararse con el tiempo si la arquitectura no es sólida desde el comienzo.</p>\n<p>Respecto a los paradigmas de programación, Martin nos lleva a través de un recorrido que subraya cómo el software es usualmente la combinación de varios de estos paradigmas y no dogmáticamente uno sobre otro.</p>\n<p>Sobre todo, el libro es un tratado sobre principios — desde los principios SOLID hasta los principios de Componentes, Arquitectura y Capas —, culminando en la discusión de patrones de diseño comunes que sirven para cumplir con lo que podría considerarse el corazón de Clean Architecture: <em>The Dependency Rule</em>.</p>\n<h2>The Dependency Rule y la verdadera esencia de Clean Architecture</h2>\n<p>Si pudiera ejemplificar brevemente la esencia de Clean Architecture en un ejemplo de código, seria algo asi:</p>\n<pre><code class=\"language-ts\">import React, { useReducer, useCallback, FormEvent } from \"react\";\n\n// Esta interfaz representa el contrato para la capa de lógica de negocio.\n// Define la regla de negocio específica de la aplicación para crear un usuario.\ninterface ICreateUserService {\n  (data: { name: string; email: string }): Promise&#x3C;void>;\n}\n\n// Este hook representa la implementación del caso de uso.\n// Idealmente debería estar en un archivo separado y podría mejorarse\n// inyectando dependencias que realicen las solicitudes de red reales,\n// haciéndolo más adaptable a cambios en servicios externos.\nfunction useCreateUserService(): ICreateUserService {\n  const execute = useCallback(async ({ name, email }) => {\n    // Aquí es donde normalmente interactuarías con un servicio externo,\n    // como una API. La interacción con la API debería ser extraída a un\n    // módulo separado para adherirse al Principio de Inversión de Dependencias.\n    await new Promise((resolve) => setTimeout(resolve, 2000));\n    console.debug(`User created: ${name} (${email})`);\n  }, []);\n\n  return execute;\n}\n\n// This represents the initial state of the form and should be self-explanatory.\nconst initialState = {\n  name: \"\",\n  email: \"\",\n  loading: false,\n};\n\ntype State = typeof initialState;\n\ntype Action = {\n  type: \"SET_NAME\" | \"SET_EMAIL\" | \"SET_LOADING\" | \"RESET_FORM\";\n  payload?: Partial&#x3C;State>;\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"SET_NAME\":\n      return { ...state, name: action.payload!.name! };\n    case \"SET_EMAIL\":\n      return { ...state, email: action.payload!.email! };\n    case \"SET_LOADING\":\n      return { ...state, loading: action.payload!.loading! };\n    case \"RESET_FORM\":\n      return initialState;\n    default:\n      return state;\n  }\n}\n\n// Este componente representa parte de la capa UI.\n// Debería ser responsable solo de renderizar y delegar interacciones de usuario\n// a los casos de uso/reglas de negocio.\nfunction UserForm({ createUser }: { createUser: ICreateUserService }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Este callback representa la interacción del usuario con el formulario.\n  // Podria ser extraido a un componente separado para adherirse al Principio de Responsabilidad Única.\n  const handleSubmit = useCallback(\n    async (e: FormEvent) => {\n      e.preventDefault();\n      dispatch({ type: \"SET_LOADING\", payload: { loading: true } });\n      try {\n        await createUser({ name: state.name, email: state.email });\n        dispatch({ type: \"RESET_FORM\" });\n      } finally {\n        dispatch({ type: \"SET_LOADING\", payload: { loading: false } });\n      }\n    },\n    [createUser, state],\n  );\n\n  // Los elementos del formulario deberían extraerse en componentes separados\n  // para adherirse al Principio de Responsabilidad Única.\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input\n        placeholder=\"name\"\n        type=\"text\"\n        value={state.name}\n        onChange={(e) =>\n          dispatch({ type: \"SET_NAME\", payload: { name: e.target.value } })\n        }\n      />\n      &#x3C;br />\n      &#x3C;input\n        placeholder=\"email\"\n        type=\"email\"\n        value={state.email}\n        onChange={(e) =>\n          dispatch({ type: \"SET_EMAIL\", payload: { name: e.target.value } })\n        }\n      />\n      &#x3C;br />\n      &#x3C;button disabled={state.loading} type=\"submit\">\n        Create User\n      &#x3C;/button>\n    &#x3C;/form>\n  );\n}\n\n// Este componente App es parte de la capa más externa que compone la UI con los casos de uso.\nexport default function App() {\n  const createUser = useCreateUserService();\n  return &#x3C;UserForm createUser={createUser} />;\n}\n\n</code></pre>\n<p>El código satisface a la Clean Architecture dado que:</p>\n<p>Separación de preocupaciones: El código intenta separar las responsabilidades dividiendo la lógica en funciones y componentes. La interfaz ICreateUserService define un contrato para la creación de usuarios, y el hook useCreateUserService implementa esta lógica. Esto es coherente con los principios de Clean Architecture de separar las reglas de negocio de la UI.</p>\n<p>La Regla de Dependencia: La Regla de Dependencia establece que las dependencias deben apuntar hacia adentro, desde las capas externas (como la UI) hacia las capas internas (como la lógica de negocio y los datos). En el código proporcionado, el componente UserForm depende de ICreateUserService, lo que es un buen ejemplo de inversión de dependencias y la separación entre la UI y la lógica de negocio.</p>\n<p>Principios SOLID: El principio de Inversión de Dependencias (D en SOLID) está presente en la interfaz ICreateUserService.</p>\n<h2>En conclusión</h2>\n<p>Como lo dice el buen libro de <a href=\"https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea\">Eric Eliot, Composing Software</a>. La composicion es la esencia de la programación. El ejemplo que vimos se reduce a aplicar en React simple composicion, de forma que, todos los principios y reglas que conforman la arquitectura tienen un mismo origen que la programacion misma y la Rule of Dependency es solo un alias de la composicion.</p>\n<p>El proceso de diseño y arquitectura no se basa en seguir un ejemplo o una guia MVC, MVP, MVVM, etc. Se basa en entender los principios y reglas que de tan herramientas y patrones de diseño, y aplicarlos de forma que se adapten a tu problema. No existe una estructura definida llamada \"Clean Arquitecture\" por Uncle Bob. Uncle Bob solo nos dio una guia de los principios y reglas que el usa para diseñar software, y que tu puedes usar para diseñar el tuyo.</p>\n<p>Alguna otra referencia que me gusta muchos sobre separaciones por capas <a href=\"https://www.gobeyond.dev/packages-as-layers/\">Packages as layers, not groups</a>.</p>\n","cover":{"alt":"Sere honesto contigo dev. No existe la Clean Architecture","src":"clean.jpg"},"excerpt":"Contrario a lo que muchos asocian con Clean Architecture, el libro de Robert C. Martin no se limita a las cuatro capas propuestas en su famoso artículo, ni se enfoca en una prescripción rígida de la estructura de carpetas — salvo por una breve discusión en el último capítulo."}},"__N_SSG":true}